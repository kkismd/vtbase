;; PPU I/O registers
PPU_CTRL1       :=$2000
PPU_CTRL2       :=$2001
PPU_STATUS      :=$2002
PPU_SPR_ADDR    :=$2003
PPU_SPR_IO      :=$2004
PPU_VRAM_ADDR1  :=$2005
PPU_VRAM_ADDR2  :=$2006
PPU_VRAM_IO     :=$2007

BG_PALETTE_TBL  :=$3f00
SPR_PALETTE_TBL :=$3f10

;; constants
SCREEN_WIDTH    :=32
SCREEN_HEIGHT   :=29
;; gamepad
PAD_A           :=$01
PAD_B           :=$02
PAD_SELECT      :=$04
PAD_START       :=$08
PAD_U           :=$10
PAD_U_NOT       :=$ef
PAD_D           :=$20
PAD_D_NOT       :=$df
PAD_L           :=$40
PAD_L_NOT       :=$bf
PAD_R           :=$80
PAD_R_NOT       :=$7f

K_RETURN        :=$01
K_KANA          :=$02
K_RSHIFT        :=$03
K_STOP          :=$04
K_ESC           :=$05
K_CTR           :=$06
K_LSHIFT        :=$07
K_GRPH          :=$08
K_CLR           :=$09
K_UP            :=$0A
K_RIGHT         :=$0B
K_LEFT          :=$0C
K_DOWN          :=$0D
K_DEL           :=$0E
K_INS           :=$0F
K_F1            :=$11
K_F2            :=$12
K_F3            :=$13
K_F4            :=$14
K_F5            :=$15
K_F6            :=$16
K_F7            :=$17
K_F8            :=$18
S_SHIFT        :=$01
S_CTRL         :=$02
S_GRAPH        :=$04

VRAM_NAME_TBL   :=$2000
VRAM_ATTR_TBL   :=$23c0

APU_DMC_IRQ     :=$4010
APU_STATUS      :=$4015
KBD_CTRL        :=$4016
KBD_IO          :=$4017
APU_FRAME_CNT   :=$4017

CMD_ERASE_LINE  :=$f0

                                ;  https://github.com/bbbradsmith/NES-ca65-example
                                ;  example.s
                                ;  Brad Smith (rainwarrior), 4/06/2014
                                ;  http://rainwarrior.ca

                                ;  ## License
                                ;  This program and source code can be freely redistributed, modified or reused in any way.
                                ;  Credit is not required, but attribution is always appreciated.

                                ;  .segment "OAM"
OAM             :=$0200         ;  oam: .res 256        ; sprite OAM data to be uploaded by DMA
                                ;  .segment "BSS"
nmt_update      :=$0300         ;  nmt_update: .res 256 ; nametable update entry buffer for PPU update
palette         :=$0400         ;  palette:    .res 32  ; palette buffer for PPU update
line_buf        :=$0420         ;  line_buf    .res 32  ; line input buffer (line contents at cursor Y)
token           :=$0440         ;  token len   .res 1
token_s         :=$0441         ;  token buf   .res 31
random          :=$0460         ;  4 bytes random seed
ptr             :=$0464

;; zero page                    ;  .segment "ZEROPAGE"
nmi_lock        :=$00           ;  nmi_lock:       .res 1 ; prevents NMI re-entry
nmi_count       :=$01           ;  nmi_count:      .res 1 ; is incremented every NMI
nmi_ready       :=$02           ;  nmi_ready:      .res 1 ; set to 1 to push a PPU frame update,
                                ;                         ; 2 to turn rendering off next NMI
nmt_update_len  :=$03           ;  nmt_update_len: .res 1 ; number of bytes in nmt_update buffer
scroll_y        :=$04           ;  scroll_y:       .res 1 ; y scroll position
scroll_nmt      :=$05           ;  scroll_nmt:     .res 1 ; nametable select (0-3 = $2000,$2400,$2800,$2C00)

temp            :=$07           ;  temp:           .res 1 ; temporary variable
gamepad         :=$08           ;  gamepad:        .res 1
cursor_x        :=$09           ;  cursor_x: .res 1
cursor_y        :=$0a           ;  cursor_y: .res 1
temp_x          :=$0b           ;  temp_x:   .res 1
temp_y          :=$0c           ;  temp_y:   .res 1
upd             :=$0d
offset_x        :=$0e
offset_y        :=$0f
buttons         :=$10           ;  button push state
p_timer         :=$11           ;  player animation timer
xsave           :=$12
ysave           :=$13
hex_h           :=$14
tmp1            :=$15
tmp2            :=$16
keyin_data      :=$17           ;  9 bytes (17 ~ 1f)
keyin_offset    :=$20
keyin_bit       :=$21
keycode_offset  :=$22
keydown         :=$23
keydown_prev    :=$24
shift_state     :=$25
addrhi          :=$26
addrlo          :=$27
N               :=$28           ; 8 bytes ($28 ~ $2f)

nes_header                      ;  iNESヘッダ
        ?="NES",$1A             ;  "NES" Header
        ?=$02                   ;   PRG-BANKS
        ?=$01                   ;   CHR-BANKS
        ?=$00                   ;   vertical Mirror
        ?=$00                   ;
        ?=$00,$00,$00,$00       ;
        ?=$00,$00,$00,$00       ;

        *=$8000                 ;  .segment "STARTUP"

reset                           ;  proc Reset
        I=1                     ;       sei
        A=0                     ;       lda #0
        (PPU_CTRL1)=A           ;       sta $2000
        (PPU_CTRL2)=A           ;       sta $2001
        (APU_STATUS)=A          ;       sta $4015 ; disable APU sound
        (APU_DMC_IRQ)=A         ;       sta $4010 ; disable DMC IRQ
        A=$40                   ;       lda #$40
        (APU_FRAME_CNT)=A       ;       sta $4017 ; disable APU IRQ
        D=0                     ;       cld       ; disable decimal mode
        X=$ff                   ;       ldx #$ff
        S=X                     ;       txs

                                ;;; wait for first vblank
        T=A&(PPU_STATUS)        ;       bit $2002
.1                              ;       :
        T=A&(PPU_STATUS)        ;       bit $2002
        ;=PL,.1                 ;       bpl :-

                                ;  ; clear all RAM to 0
        A=0                     ;  lda #0
        X=0                     ;  ldx #0
.2                              ;  :
        ($00+X)=A               ;     sta $0000, X
        ($0100+X)=A             ;     sta $0100, X
        ($0200+X)=A             ;     sta $0200, X
        ($0300+X)=A             ;     sta $0300, X
        ($0400+X)=A             ;     sta $0400, X
        ($0500+X)=A             ;     sta $0500, X
        ($0600+X)=A             ;     sta $0600, X
        ($0700+X)=A             ;     sta $0700, X
        X=+                     ;     inx
        ;=NE,.2                 ;     bne :-
                                ;  ; place all sprites offscreen at Y=255
        A=255                   ;  lda #255
        X=0                     ;  ldx #0
.3                              ;  :
        (OAM+X)=A               ;          sta oam, X
        X=++++                  ;          inx
                                ;          inx
                                ;          inx
                                ;          inx
        ;=NE,.3                 ;          bne :-
                                ;  ; wait for second vblank
.4                              ;  :
        T=A&(PPU_STATUS)        ;          bit $2002
        ;=PL,.4                 ;          bpl :-

                                ;  ; NES is initialized, ready to begin!
                                ;  ; enable the NMI for graphical updates, and jump to our main program
        A=%10001000             ;  lda #%10001000
        (PPU_CTRL1)=A           ;  sta $2000
        #=main                  ;  jmp main

nmi                             ;  nmi:
                                ;      ; save registers
        [=A                     ;      pha
        A=X                     ;      txa
        [=A                     ;      pha
        A=Y                     ;      tya
        [=A                     ;      pha
                                ;      ; prevent NMI re-entry
        A=(nmi_lock)            ;      lda nmi_lock
        ;=EQ,.1                 ;      beq :+
        #=.nmi_end              ;          jmp @nmi_end
.1                              ;      :
        A=1                     ;      lda #1
        (nmi_lock)=A            ;      sta nmi_lock
                                ;      ; increment frame counter
        (nmi_count)=+           ;      inc nmi_count
                                ;      ;
        A=(nmi_ready)           ;      lda nmi_ready
        ;=NE,.2                 ;      bne :+ ; nmi_ready == 0 not ready to update PPU
        #=.ppu_update_end       ;          jmp @ppu_update_end
.2                              ;      :
        T=A-2                   ;      cmp #2 ; nmi_ready == 2 turns rendering off
        ;=NE,.3                 ;      bne :+
        A=%00000000             ;          lda #%00000000
        (PPU_CTRL2)=A           ;          sta $2001
        X=0                     ;          ldx #0
        (nmi_ready)=X           ;          stx nmi_ready
        #=.ppu_update_end       ;          jmp @ppu_update_end
.3                              ;      :
                                ;      ; sprite OAM DMA
        X=0                     ;      ldx #0
        (PPU_SPR_ADDR)=X        ;      stx $2003
        A=>OAM                  ;      lda #>oam
        ($4014)=A               ;      sta $4014
                                ;      ; palettes
        A=%10001000             ;      lda #%10001000
        (PPU_CTRL1)=A           ;      sta $2000 ; set horizontal nametable increment
        A=(PPU_STATUS)          ;      lda $2002
        A=$3f                   ;      lda #$3F
        (PPU_VRAM_ADDR2)=A      ;      sta $2006
        (PPU_VRAM_ADDR2)=X      ;      stx $2006 ; set PPU address to $3F00
        X=0                     ;      ldx #0
.4                              ;      :
        A=(palette+X)           ;          lda palette, X
        (PPU_VRAM_IO)=A         ;          sta $2007
        X=+                     ;          inx
        T=X-32                  ;          cpx #32
        ;=CC,.4                 ;          bcc :-
                                ;      ; nametable update
        X=0                     ;      ldx #0
        T=X-(nmt_update_len)    ;      cpx nmt_update_len
        ;=CS,.scroll            ;      bcs @scroll
.nmt_update_loop                ;      @nmt_update_loop:
        A=(nmt_update+X)        ;          lda nmt_update, X
        (PPU_VRAM_ADDR2)=A      ;          sta $2006
        X=+                     ;          inx
        A=(nmt_update+X)        ;          lda nmt_update, X
        (PPU_VRAM_ADDR2)=A      ;          sta $2006
        X=+                     ;          inx
        A=(nmt_update+X)        ;          lda nmt_update, X
        ;=A<$f0 #=.normal_command
            A=$20
            Y=30
.loop
                (PPU_VRAM_IO)=A
                Y=-
            ;=NE,.loop
.normal_command
        (PPU_VRAM_IO)=A         ;          sta $2007
        X=+                     ;          inx
        T=X-(nmt_update_len)    ;          cpx nmt_update_len
        ;=CC,.nmt_update_loop   ;          bcc @nmt_update_loop
        A=0                     ;      lda #0
        (nmt_update_len)=A      ;      sta nmt_update_len
.scroll                         ;  @scroll:
        !=sync_line_buffer
        A=(scroll_nmt)          ;      lda scroll_nmt
        A=A&%00000011           ;      and #%00000011 ; keep only lowest 2 bits to prevent error
        A=A|%10001000           ;      ora #%10001000
        (PPU_CTRL1)=A           ;      sta $2000

        A=0                     ;      ; set value of scroll_x
        (PPU_VRAM_ADDR1)=A      ;      sta $2005

        A=(scroll_y)            ;      ; set value of scroll_y
        A=<<<                   ;       A=A*8
        (PPU_VRAM_ADDR1)=A      ;      sta $2005
                                ;      ; enable rendering
        A=%00011110             ;      lda #%00011110
        (PPU_CTRL2)=A           ;      sta $2001
                                ;      ; flag PPU update complete
        X=0                     ;      ldx #0
        (nmi_ready)=X           ;      stx nmi_ready

.ppu_update_end                 ;  @ppu_update_end:
                                ;      ; if this engine had music/sound, this would be a good place to play it
                                ;      ; unlock re-entry flag
        A=0                     ;      lda #0
        (nmi_lock)=A            ;      sta nmi_lock
.nmi_end                        ;  @nmi_end:
                                ;      ; restore registers and return
        A=]                     ;      pla
        Y=A                     ;      tay
        A=]                     ;      pla
        X=A                     ;      tax
        A=]                     ;      pla
        #=~                     ;      rti

                                ;  .segment "CODE"
irq                             ;  irq:
        #=~                     ;      rti

                                ;  ; ppu_update: waits until next NMI, turns rendering on (if not already),
                                ;    uploads OAM, palette, and nametable update to PPU
ppu_update                      ;  ppu_update:
        A=1                     ;      lda #1
        (nmi_ready)=A           ;      sta nmi_ready
.1                              ;      :
        A=(nmi_ready)           ;          lda nmi_ready
        ;=NE,.1                 ;          bne :-
        #=!                     ;      rts
                                ;
                                ;  ; ppu_skip: waits until next NMI, does not update PPU
ppu_skip                        ;  ppu_skip:
        A=(nmi_count)           ;      lda nmi_count
.1                              ;      :
        T=A-(nmi_count)         ;          cmp nmi_count
        ;=EQ,.1                 ;          beq :-
        #=!                     ;      rts
                                ;
                                ;  ; ppu_off: waits until next NMI, turns rendering off
                                ;    (now safe to write PPU directly via $2007)
ppu_off                         ;  ppu_off:
        A=2                     ;      lda #2
        (nmi_ready)=A           ;      sta nmi_ready
.1                              ;      :
        A=(nmi_ready)           ;          lda nmi_ready
        ;=NE,.1                 ;          bne :-
        #=!                     ;      rts

sync_line_buffer
        ;;; save addrhi,lo
        A=(addrhi)
        [=A
        A=(addrlo)
        [=A
        ;;; set PPU I/O address
        A=(scroll_y)
        A=A+(cursor_y)
        Y=A
        X=0
        !=ppu_address_tile
        A=(PPU_STATUS)          ; reset latch
        A=(addrhi)
        (PPU_VRAM_ADDR2)=A
        A=(addrlo)
        (PPU_VRAM_ADDR2)=A
        A=(PPU_VRAM_IO)         ; dummy read

        ;;; read from ppu
        X=0                     ;    LDX #$00
.loop                           ;  CopyLoop:
        A=(PPU_VRAM_IO)         ;    LDA $2007
        (line_buf+X)=A          ;    STA $0400,X
        X=+                     ;    INX
        T=X-$20                 ;    CPX #$20
        ;=NE,.loop              ;    BNE CopyLoop

        ;;; restore addrhi,lo
        A=]
        (addrlo)=A
        A=]
        (addrhi)=A
        #=!                     ;    RTS

; ppu_address_tile  calculate ppu address from X,Y
; IN
;   X -- X coord
;   Y -- Y coord (scroll_y + cursor_y)
; USE
;   A -- accumulate
; OUT
;   addrhi -- ppu address hi
;   addrlo -- ppu address lo
;
;   scroll_nmt    0   2
;   -----------|----------
;    Y <  30   |  T   B     (T = Top -> $2000)
;      >= 30   |  B   T     (B = Bottom -> $2800)
;
ppu_address_tile
        ;=Y>30 #=.else
.then
        A=(scroll_nmt)
        ;=A=0 A=$20
        ;=A=2 A=$28
        #=.endif
.else
        A=Y
        A=A-30
        Y=A
        A=(scroll_nmt)
        ;=A=0 A=$28
        ;=A=2 A=$20
.endif
        (addrhi)=A
        A=Y
        A=>>>
        A=A+(addrhi)
        (addrhi)=A
        A=Y
        A=<<<<<
        (addrlo)=A
        A=X
        A=A|(addrlo)
        (addrlo)=A

        #=!

; IN
;   A -- tile char
;   X -- X coord
;   Y -- Y coord
; USE
;   addrhi -- ppu address hi
;   addrlo -- ppu address lo
ppu_update_tile
        [=A                     ; save tile char
        !=ppu_address_tile      ; calculate ppu address
        X=(nmt_update_len)
        A=(addrhi)
        (nmt_update+X)=A        ; write address hi
        X=+                     ; advance pointer
        A=(addrlo)
        (nmt_update+X)=A        ; write address lo
        X=+                     ; advance pointer
        A=]                     ; restore tile char
        (nmt_update+X)=A
        X=+                     ;  inx
        (nmt_update_len)=X      ;  stx nmt_update_len
        #=!

;; gamepad_poll: this reads the gamepad state into the variable labelled "gamepad"
;;   This only reads the first gamepad, and also if DPCM samples are played they can
;;   conflict with gamepad reading, which may give incorrect results.
gamepad_poll                ;  gamepad_poll:
                            ;      ; strobe the gamepad to latch current button state
    A=1                     ;      lda #1
    ($4016)=A               ;      sta $4016
    A=0                     ;      lda #0
    ($4016)=A               ;      sta $4016
                            ;      ; read 8 bytes from the interface at $4016
    X=8                     ;      ldx #8
.1                          ;      :
    [=A                     ;          pha
    A=($4016)               ;          lda $4016
                            ;          ; combine low two bits and store in carry bit
    A=A&%00000011           ;          and #%00000011
    T=A-%00000001           ;          cmp #%00000001
    A=]                     ;          pla
                            ;          ; rotate carry into gamepad variable
    A=)                     ;          ror
    X=-                     ;          dex
    ;=NE,.1                 ;          bne :-
    (gamepad)=A             ;      sta gamepad
    #=!                     ;      rts

main                        ;     ; setup
    X=0                     ;     ldx #0
.1                          ;     :
    A=(example_palette+X)   ;         lda example_palette, X
    (palette+X)=A           ;         sta palette, X
    X=+                     ;         inx
    T=X-32                  ;         cpx #32
    ;=CC,.1                 ;         bcc :-
    !=setup_background      ;     jsr setup_background
                            ;     ; center the cursor
    A=0                     ;     lda #128
    (cursor_x)=A            ;     sta cursor_x
    (cursor_y)=A            ;     sta cursor_y
    (p_timer)=A
    (buttons)=A
    (keydown)=A
    (keydown_prev)=A
    (scroll_nmt)=A
    (scroll_y)=A
                            ;     ; show the screen
    !=draw_cursor           ;     jsr draw_cursor
    !=ppu_update            ;     jsr ppu_update
                            ;     ; main loop
.loop                       ;;@loop:
                            ;     ; read gamepad
    !=gamepad_poll          ;     jsr gamepad_poll
                            ;     ; respond to gamepad state
    A=(gamepad)             ;     lda gamepad
    A=A&PAD_START           ;     and #PAD_START
    ;=EQ,.2                 ;     beq :+
    !=push_start            ;         jsr push_start
    #=.draw                 ;         jmp @draw ; start trumps everything, don't check other buttons
.2                          ;     :

    !=handle_cross_key
    A=(gamepad)             ;     lda gamepad
    A=A&PAD_SELECT          ;     and #PAD_SELECT
    ;=EQ,.7                 ;     beq :+
    !=push_select           ;         jsr push_select
.7                          ;     :
    A=(gamepad)             ;     lda gamepad
    A=A&PAD_B               ;     and #PAD_B
    ;=EQ,.8                 ;     beq :+
    !=push_b                ;         jsr push_b
.8                          ;     :
    A=(gamepad)             ;     lda gamepad
    A=A&PAD_A               ;     and #PAD_A
    ;=EQ,.9                 ;     beq :+
    !=push_a_btn                ;         jsr push_a
.9                          ;     :
    !=read_keyboard
    !=check_shift_state
    !=display_keyin_char

.draw                       ;;@draw:
                            ;     ; draw everything and finish the frame
    !=draw_cursor           ;     jsr draw_cursor
    !=ppu_update            ;     jsr ppu_update
                            ;     ; keep doing this forever!
    #=.loop                 ;     jmp @loop

handle_cross_key
    !=is_up_key_pressed
    ;=EQ,.check_down_key
    A=(buttons)             ;  check state
    ;=NE,.1
    !=push_u
    A=1                     ;  set flag on
    (buttons)=A
.1
    #=!
.check_down_key
    !=is_down_key_pressed
    ;=EQ,.check_left_key
    A=(buttons)             ;  check state
    ;=NE,.2
    !=push_d
    A=1                     ;  set flag on
    (buttons)=A
.2
    #=!
.check_left_key
    !=is_left_key_pressed
    ;=EQ,.check_right_key
    A=(buttons)             ;  check state
    ;=NE,.3
    !=push_l
    A=1                     ;  set flag on
    (buttons)=A
.3
    #=!
.check_right_key
    !=is_right_key_pressed
    ;=EQ,.no_button_pressed
    A=(buttons)             ;  check state
    ;=NE,.4
    !=push_r                ;         jsr push_r
    A=1                     ;  set flag on
    (buttons)=A
.4
    #=!
.no_button_pressed
    A=0                     ;  reset button pushed
    (buttons)=A             ;  because no button pushed
    #=!

; pad up button or kbd up key is pressed?
is_up_key_pressed
    A=(gamepad)
    A=A&PAD_U
    #=!

; pad down button or kbd down key is pressed?
is_down_key_pressed
    A=(gamepad)
    A=A&PAD_D
    #=!

; pad left button or kbd left key is pressed?
is_left_key_pressed
    A=(gamepad)
    A=A&PAD_L
    #=!

is_right_key_pressed
        A=(gamepad)
        A=A&PAD_R
        #=!

check_shift_state
        ; init state
        A=0
        (shift_state)=A

.test_right_shift
        A=(keyin_data)
        A=A^$ff
        A=A&$20
        ;=Z,.test_left_shift
            ; if shift key pressed
            A=S_SHIFT
            (shift_state)=A
            #=.test_ctrl

.test_left_shift
        A=(keyin_data+7)
        A=A^$ff
        A=A&$10
        ;=EQ,.test_ctrl
            ; if shift key pressed
            A=S_SHIFT
            (shift_state)=A

.test_ctrl
        A=(keyin_data+7)
        A=A^$ff
        A=A&$08
        ;=Z,.test_graph
            ; if ctrl key pressed
            A=(shift_state)
            A=A|S_CTRL
            (shift_state)=A

.test_graph
        ; test graph key
        A=(keyin_data+7)
        A=A^$ff
        A=A&$20
        ;=Z,.ret
            ; if graph key pressed
            A=(shift_state)
            A=A|S_GRAPH
            (shift_state)=A
.ret
        #=!

display_keyin_char
    ; initialize keydown state for this cycle
    A=0
    (keydown)=A
    ; initialize keyin and keycode variables
    (keyin_offset)=A
    (keycode_offset)=A
    (keyin_bit)=A
    (keyin_bit)=+
.loop
      !=disp_keyin_data
      (keyin_offset)=+
      A=(keyin_offset)
      ;=A>9 #=.end
      A=<<<
      (keycode_offset)=A        ; keycode_offset = keyin_offset * 8
      A=1
      (keyin_bit)=A
      #=.loop
.end
    ; update last keydown state for next cycle
    A=(keydown)
    (keydown_prev)=A

    #=!

disp_keyin_data
.loop
    !=keyboard_test         ; Is the current key being pressed?
    ;=EQ,.next              ;   If not pressed, go to the next loop
    !=scan_code             ; If the current keycode is different
    T=A-(keydown_prev)      ;   from the previously pressed keycode
    ;=EQ,.keydown           ;   skip displaying
    !=put_char              ; then call put_char
.keydown
    !=scan_code
    (keydown)=A             ; mark new-keydown on
    #=!
.next
    (keycode_offset)=+
    C=0
    (keyin_bit)=<           ; shift left testing bit
    ;=CC,.loop              ; bit8 has done.
    #=!

; test keyin data
; IN
;   keyin_offset, keyin_bit
; USE A, X
;
keyboard_test
    A=(shift_state)
    ;=Z,.not_shift_key
    ; ignore shift keys
    ; keyin_offset == 7 && keyin_bit == $08 | $10 | $20
    ;              or 0 &&              $20
    A=(keyin_offset)
    T=A-7
    ;=NE,.test_offset0
    A=(keyin_bit)
    ;=A=$08 #=.is_shift_key
    ;=A=$10 #=.is_shift_key
    ;=A=$20 #=.is_shift_key
.test_offset0
    A=(keyin_offset)
    ;=A\0 #=.not_shift_key
    A=(keyin_bit)
    ;=A\$20 #=.not_shift_key
.is_shift_key
    A=A&0
    #=!

.not_shift_key
    ; read key data
    X=(keyin_offset)
    A=(keyin_data+X)
    A=A^$ff
    A=A&(keyin_bit)
    #=!

; keyboard matrix code
; IN
;   keyin_offset, keyin_bit
; OUT A
; USE temp
scan_code
    A=(keyin_offset)
    A=<<<<
    (temp)=A
    A=(keyin_bit)
    A=A|(temp)
    #=!

; put char at cursor pos and shift right
; IN
;   keycode_offset, cursor_x, cursor_y
; USE A, X, Y
put_char
    ; change table with shift state
    A=(shift_state)
    A=A&S_SHIFT
    ;=Z,.non_shift
        ; if shift on
        X=(keycode_offset)
        A=(keycode_table_shifted+X)
        ;=A<$20 #=control_char
        [=A                     ; save char code
        #=.cont

.non_shift
    X=(keycode_offset)
    A=(keycode_table+X)
    ;=A<$20 #=control_char
    [=A                     ; save char code

.cont
    A=(cursor_y)
    A=A+(scroll_y)
    Y=A
    A=]                     ; restore char code
    X=(cursor_x)
    !=ppu_update_tile
    ; fall through
advance_cursor
    ; Move cursor one step to the right.
    A=(cursor_x)
    ;=A<31 (cursor_x)=+ #=!
    ; move to the left edge of the next line if at the right edge.
    A=0
    (cursor_x)=A
    (cursor_y)=+
    ; Move to the top line if at the bottom edge.
    ;=Y>31 (cursor_y)=A
    #=!

; Control Keys pressed. (not CTR key)
control_char
    ;=A=K_UP        #=push_u
    ;=A=K_DOWN      #=push_d
    ;=A=K_LEFT      #=push_l
    ;=A=K_RIGHT     #=push_r
    ;=A=K_CLR       #=push_select
    ;=A=K_KANA      #=push_start
    ;=A=K_RETURN    #=push_return
    #=!

;; return key pressed
push_return
    X=0                             ; data stack pointer
    Y=0                             ; program text index
    A=$20                           ; print space after input line
    !=cout
    !=eval
    !=carriage_return

ok
    A='O'
    !=cout
    A='k'
    !=cout

    #=carriage_return

    #=!

; read program text and evaluate
; IN
;     Y -- line buffer current position
;     X -- data stack pointer
; USE
;     A
; OUT
;     Y -- line buffer new position
;     X -- data stack pointer
eval
    !=skip_blank
    ;=Y>$1f #=.loop_end                     ; check if line end
    !=execute
    #=eval  ; goto top
.loop_end
    #=!

; exec word or push digit
execute
    A=(line_buf+Y)
    ;=A<'0' #=.word
    ;=A>':' #=.word
    #=push_digit
.word
    #=find_and_exec

push_digit
    !=push_zero
.loop
    A=(line_buf+Y)
    ;=A<'0' #=.loop_end
    ;=A>':' #=.loop_end                     ; next of '9'
    A=A-$30                                 ; digit to decimal value

    X=--                                    ; push value        -> [base, value]
    [0]=A
    A=0 [1]=A
    (ysave)=Y                               ; save Y
    !=swap                                  ; swap stack        -> [value, base]
    Y=(ysave)                               ; restore Y

    X=--                                    ; push const 10     -> [value, base, 10]
    A=10 [0]=A
    A=0  [1]=A

    (ysave)=Y                               ; save Y
    !=star                                  ;                   -> [value, base*10]
    !=plus                                  ;                   -> [value+base]
    Y=(ysave)                               ; restore Y

    Y=+                                     ; next input
    ;=Y<$1f #=.loop
.loop_end
    #=!

; 辞書からワードを検索して一致したら実行
find_and_exec
        !=tokenize
        (ysave)=Y
        A=<DICT (N+0)=A         ; address of dict entry
        A=>DICT (N+1)=A
        A=<token (N+2)=A        ; address of token buffer
        A=>token (N+3)=A
.loop
        !=strequ
        ;=EQ,.hit
.miss
        X=--                    ; dict header layout
        A=(N+0)                 ; 930A      = $0A               <- length
        (0+X)=A                 ; 930B~9314 = 'fetch_byte'      <- word name
        A=(N+1)                 ; 9315~9316 = $1F $89           <- link to previous
        (1+X)=A                 ;        $930A | <- Stack Bottom           
        !=dup                   ;  $930A $930A |
        !=fetch_byte            ;  $000A $930A |
        !=plus                  ;        $9314 |
        !=one_plus              ;        $9315 |
        !=fetch                 ;        $891F |
        A=(0+X)                 ; 
        (N+0)=A                 ; (N+0) <- $1F
        A=(1+X)                 ;
        (N+1)=A                 ; (N+1) <- $89
        X=++                    ; DROP
        A=A|(N+0)               ; zero check
          ;=EQ,.err             ;   yes -> end of dict
        #=.loop
.hit
        ; execute word routine:  N+len+2 = word subroutine address

        !=push_from_N
        Y=0
        A=[N]+Y
        !=push_byte
        A=3
        !=push_byte
        !=plus
        !=plus
        Y=(ysave)
        !=indirect_jsr
        #=!
.err
        A='?'
        !=cout
        !=carriage_return
        Y=(ysave)
        Y=+
        #=!

; indirect subroutine call
; (addr  --  )
indirect_jsr
        A=1
        !=push_byte
        !=minus
        A=(1+X)
        [=A
        A=(0+X)
        [=A
        X=++
        #=!

; skip space characters on program text
;   IN   Y program text index
;   USE  A
;   OUT  Y new index pos
skip_blank
        ;=Y>$1f #=!
        A=(line_buf+Y)
        ;=A=$20 Y=+ #=skip_blank
        #=!


; put char to screen
; IN   A
cout
    (xsave)=X
    (ysave)=Y
    [=A                     ; save char code

    A=(cursor_y)
    A=A+(scroll_y)
    Y=A
    A=]                     ; restore char code
    X=(cursor_x)
    !=ppu_update_tile
    !=advance_cursor

    Y=(ysave)
    X=(xsave)
    #=!

; Output a 8 bit value in hexadecimal format
;   ( b --  )
put_hex
        !=numhex            ; Convert a byte value to a two-digit character.
        A=(0+X)             ; Extract the first digit
        !=cout              ; output
        A=(1+X)             ; Extract the senond digit
        !=cout              ; output
        X=++                ; Consume the stack
        #=!

; Output a 16 bit value in decimal format
;   ( d -- )
put_decimal
        A=0                 ; put null delimiter
        [=A
.1
            X=--            ; push const 10     -> [value, 10]
            A=10 [0]=A
            A=0  [1]=A
            !=divmod        ; call divmod       -> [div, mod]
            A=[0]           ; mod value
            A=A+'0'         ;   convert to ascii
            [=A             ;   push A to the system stack
            X=++            ; drop mod value    -> [div]
            A=(0+X)           ; if div == 0 then stop
            A=A|(1+X)
            ;=NE,.1         ; else repeat again
        X=++                ; drop the last div value (=0)
        A=]
.2
        !=cout
        A=]
        ;=NE,.2

        #=!

; do carriage return and scroll up
carriage_return
        A=0
        (cursor_x)=A            ; move ←
        (cursor_y)=+            ; move ↓
        A=(cursor_y)
        ;=A<30 #=!             ; end if within screen
        A=29
        (cursor_y)=A            ; adjust Y
        !=push_start            ; roll up

        (xsave)=X               ; save x,y
        (ysave)=Y

        A=(scroll_y)
        A=A+(cursor_y)
        Y=A
        X=0
        A=CMD_ERASE_LINE        ; set EraseLine command
        !=ppu_update_tile

        X=(xsave)
        Y=(ysave)
        A=X
        [=A
        A=Y
        [=A
        !=ppu_update
        A=]
        Y=A
        A=]
        X=A
        #=!

;-------------------------------------------------------------------------------
; stack manipulation routines
;-------------------------------------------------------------------------------
;; push zero value
push_zero
        [=A
        X=--                                    ; push initial value 0
        A=0
        (0+X)=A
        (1+X)=A
        A=]
        #=!

; push from A register    ( -- b )
push_byte
        X=--
        (0+X)=A
        A=0
        (1+X)=A
        #=!

push_from_N
        X=--
        A=(N)
        (0+X)=A
        A=(N+1)
        (1+X)=A
        #=!

pull_to_N
        A=(0+X)
        (N)=A
        A=(1+X)
        (N+1)=A
        X=++
        #=!

;;; Code from https://github.com/bbbradsmith/prng_6502
galois16                        ; galois16:
        Y=8                     ;     ldy #8
        A=(random+0)            ;     lda random+0
.1                              ; :
        A=<                     ;     asl        ; shift the register
        (random+1)=(            ;     rol random+1
        ;=CC,.2                 ;     bcc :+
        A=A^$39                 ;     eor #$39   ; apply XOR feedback whenever a 1 bit is shifted out
.2                              ; :
        Y=-                     ;     dey
        ;=NE,.1                 ;     bne :--
        (random+0)=A            ;     sta random+0
        T=A-0                   ;     cmp #0     ; reload flags
        #=!                     ;     rts

;-------------------------------------------------------------------------------

read_keyboard               ;  ReadKeyboard:
        A=%00000101             ;   lda #%00000101    ; デバイス選択＆リセット
        (KBD_CTRL)=A            ;   sta JOY1
                                ;
        !=kbd_wait2             ;   jsr Wait2
                                ;
        X=0                     ;   ldx #$00
.1      A=%00000100             ; - lda #%00000100    ; 下位データを指定
        (KBD_CTRL)=A            ;   sta JOY1
                                ;
        !=kbd_wait1             ;   jsr Wait1
                                ;
        A=(KBD_IO)              ;   lda JOY2          ; 下位データ読込
        A=>                     ;   lsr
        A=A&$0f                 ;   and #$0F
        (keyin_data+X)=A        ;   sta KeyData ,x
                                ;
        A=%00000110             ;   lda #%00000110    ; 上位データを指定
        (KBD_CTRL)=A            ;   sta JOY1
                                ;
        !=kbd_wait1             ;   jsr Wait1
                                ;
        A=(KBD_IO)              ;   lda JOY2          ; 上位データ読込
        A=<<<                   ;   asl *3
        A=A&$f0                 ;   and #$F0
        A=A|(keyin_data+X)      ;   ora KeyData ,x    ; 下位データと上位データを合成
        (keyin_data+X)=A        ;   sta KeyData ,x
                                ;
        X=+                     ;   inx
        T=X-9                   ;   cpx #$09
        ;=NE,.1                 ;   bne -
                                ;
        #=!                     ;   rts
                                ;
                                ;  ;-------------------------------------------------------------------------------
kbd_wait1                       ;  Wait1:                          ; ウエイト
        Y=8                     ;          ldy #$08
.1      Y=-                     ;        - dey
        ;=NE,.1                 ;          bne -
        _                       ;          nop
kbd_wait2                       ;  Wait2:
        #=!                     ;          rts


; 1byteの値をhex2文字に変換する
;  ( b  --  h+l )
numhex
        A=(0+X)                 ; 値を取り出す
        A=A&$0f                 ; 上位4bitをマスクする
        !=hexchar               ; 文字に変換
        (1+X)=A                 ; stackのLSBに保存

        A=(0+X)                 ; もう一度値を取り出す
        A=>>>>                  ; 上位4bitを下位にずらす
        !=hexchar               ; 文字に変換
        (0+X)=A                 ; stackのMSBに保存

        #=!                    ;  終わり

;; Aレジスタ下位4bitの値を0-Fの文字に変換する
hexchar
        ;=A>$0a A=A+7
        A=A+48
        #=!

push_u                      ;  push_u:
    (cursor_y)=-            ;      dec cursor_y
                            ;      ; Y wraps at 240
    A=(cursor_y)            ;      lda cursor_y
    ;=PL,.1                 ;      bcc :+
    A=29                    ;          lda #239
    (cursor_y)=A            ;          sta cursor_y
.1                          ;      :
    #=!                     ;      rts

push_d                      ;  push_d:
    (cursor_y)=+            ;      inc cursor_y
    A=(cursor_y)            ;      lda cursor_y
    ;=A>30 A=0 (cursor_y)=A ;  wrap over L29
    #=!                     ;      rts

push_l                      ;  push_l:
    (cursor_x)=-            ;      dec cursor_x
    A=(cursor_x)
    ;=PL,.1
    A=31
    (cursor_x)=A
.1
    #=!                     ;      rts

push_r                      ;  push_r:
    (cursor_x)=+
    A=(cursor_x)
    ;=A>32 A=0 (cursor_x)=A
.1
    #=!                     ;      rts

push_select
    #=!

push_start                  ;  push_start:
    (scroll_y)=+            ;      inc scroll_y
    A=(scroll_y)            ;      lda scroll_y
    ;=A<30 #=!
    A=0
    (scroll_y)=A
    A=(scroll_nmt)        ;  ; toggle the bit of nametable select
    A=A^$02
    (scroll_nmt)=A
    #=!

push_b                      ;  push_b:
    A=(cursor_x)            ;      lda cursor_x
    X=A                     ;      tax ; X = cursor_x
    A=(cursor_y)            ;      lda cursor_y
    Y=A                     ;      tay ; Y = cursor_y
    A=$20                   ;      lda #4
    !=ppu_update_tile       ;      jsr ppu_update_tile ; puts tile 4 at X/Y
    #=!                     ;      rts

push_a_btn                      ;  push_a:
    A=$40
    X=3
    Y=4
    !=ppu_update_tile       ;      jsr ppu_update_tile ; puts tile 4 at X/Y
    #=!                     ;      rts

draw_cursor                 ;  draw_cursor:
                            ;      ; y position (note, needs to be one line higher than sprite's appearance)
    A=(cursor_y)            ;      lda cursor_y
    A=<<<                   ;       x8
    ;=A>1 A=A-1
    (OAM)=A                 ;      sta oam+(0*4)+0
                            ;      ; tile
    A=(nmi_count)           ;      lda #1
    A=A&%01110000
    A=>>>>>
    A=A+$e0
    (OAM+1)=A               ;      sta oam+(0*4)+1
                            ;      ; attributes
    A=%00000000             ;      lda #%00000000 ; no flip
    (OAM+2)=A               ;      sta oam+(0*4)+2
                            ;      ; x position
    A=(cursor_x)            ;      lda cursor_x
    A=<<<                   ;       x8
    (OAM+3)=A               ;      sta oam+(0*4)+3
    #=!                     ;      rts

setup_background                ;  setup_background:
                                ;      ; first nametable, start by clearing to empty
        A=(PPU_STATUS)          ;      lda $2002 ; reset latch
        A=$20                   ;      lda #$20
        (PPU_VRAM_ADDR2)=A      ;      sta $2006
        A=$00                   ;      lda #$00
        (PPU_VRAM_ADDR2)=A      ;      sta $2006
                                ;      ; empty nametable
        !=init_nametable
                                ;      ; set all attributes to 0
        X=64                    ;      ldx #64 ; 64 bytes
        A=0
.3                              ;      :
        (PPU_VRAM_IO)=A         ;          sta $2007
        X=-                     ;          dex
        ;=NE,.3                 ;          bne :-

        A=(PPU_STATUS)          ;      lda $2002 ; reset latch
        A=$28                   ;      lda #$28
        (PPU_VRAM_ADDR2)=A      ;      sta $2006
        A=$00                   ;      lda #$00
        (PPU_VRAM_ADDR2)=A      ;      sta $2006

        !=init_nametable

        ; set attributes of bottom screen
        X=64                    ;      ldx #64 ; 64 bytes
        A=%01010101
.6                              ;      :
        (PPU_VRAM_IO)=A         ;          sta $2007
        X=-                     ;          dex
        ;=NE,.6                 ;          bne :-

        #=!                     ;      rts

init_nametable
        Y=30                    ;      ldy #30 ; 30 rows
.loop2                          ;      :
        X=32                    ;          ldx #32 ; 32 columns
.loop1                          ;          :
        A=$20                   ;
        (PPU_VRAM_IO)=A         ;              sta $2007
        X=-                     ;              dex
        ;=NE,.loop1             ;              bne :-
        Y=-                     ;          dey
        ;=NE,.loop2             ;          bne :--

        #=!

; string comparisons
;
; IN:  N, N+1, N+2, N+3
; USE: Y, A
; OUT: Z
strequ                          ; http://www.6502.org/source/strings/comparisons.html
        Y=0                     ; STREQU:     LDY #$00        ;Compare strings, case-sensitive
        A=[N+0]+Y               ;             LDA ($FA),Y     ;Naturally, the zero flag is used to return if the strings are equal
        T=A-[N+2]+Y             ;             CMP ($FC),Y
        ;=EQ,.1                 ;             BEQ STREQU1
        #=!                     ;             RTS
.1      Y=A                     ; STREQU1:    TAY
.loop   A=[N+2]+Y               ; STREQULP:   LDA ($FC),Y
                                ;             AND #$7F
        (N+4)=A                 ;             STA $FF
        A=[N+0]+Y               ;             LDA ($FA),Y
                                ;             AND #$7F
        T=A-(N+4)               ;             CMP $FF
        ;=NE,.ex                ;             BNE STREQUEX
        Y=-                     ;             DEY
        ;=NE,.loop              ;             BNE STREQULP
.ex     #=!                     ; STREQUEX:   RTS

; copy token to toke buffer
; first byte is length of token
; IN   line_buf, Y
; USE  N
; OUT  token, Y
tokenize
        (xsave)=X               ; save stack pointer
        X=0                     ; init token counter
.loop
        A=(line_buf+Y)          ; read from line buf
        ;=A=$20 #=.end          ; if space? then end
        (token_s+X)=A           ; write to token buf
        X=+
        Y=+
        ;=Z,.end                ; out of buffer? -> goto end
        #=.loop
.end
        A=X                     ; set token length
        (token)=A

        X=(xsave)               ; restore stack pointer
        #=!

;-------------------------------------------------------------------------------
; word execution routines

;----------------------------------------
; multiply                     ( n1 n2 -- n1*n2 )
L001    ?=1,"*"
        ?=0,0                   ; link field (last entry is zero)
;
star    A=Y [=A                 ; STAR:   PHY
        A=0 (N)=A               ;         STZ  N
        Y=0                     ;         LDY  #0
.1      >=(3+X)                 ; sta1$:     LSR  3,X
        )=(2+X)                 ;            ROR  2,X
        ;=<,.2                  ;            BCC  sta2$
        C=0                     ;               CLC
        A=(N)                   ;               LDA  N
        A=A+(0+X)               ;               ADC  0,X
        (N)=A                   ;               STA  N
        A=Y                     ;               TYA
        A=AC+(1+X)              ;            ADC  1,X
        Y=A                     ;            TAY
.2      <=(0+X)                 ; sta2$:     ASL  0,X
        (=(1+X)                 ;            ROL  1,X
                                ;
        A=(2+X)                 ;            LDA  2,X
        A=A|(3+X)               ;            ORA  3,X
        ;=\,.1                  ;         BNE  sta1$
                                ;
        A=(N)                   ;         LDA  N
        (2+X)=A                 ;         STA  2,X
        (3+X)=Y                 ;         STY  3,X
        X=++                    ;         POP
        A=]                     ;         PLY
        Y=A
        #=!                     ;         RTS

;----------------------------------------
; add                          ( n1 n2  --  n1+n2 )
L002    ?=1,"+"
        ?=L001                  ; link filed (to multiply)
;
plus                            ; PLUS:   CLC
        A=(0+X)                 ;         LDA  0,X
        A=A+(2+X)               ;         ADC  2,X
        (2+X)=A                 ;         STA  2,X
        A=(1+X)                 ;         LDA  1,X
        A=AC+(3+X)              ;         ADC  3,X
        (3+X)=A                 ;         STA  3,X
        X=++                    ;         POP
        #=!                     ;         RTS

;----------------------------------------
;; subtract                     ( n1 n2  --  n1-n2 )
L003    ?=1,"="
        ?=L002
;
minus   C=1                     ; MINUS:  SEC
        A=(2+X)                 ;         LDA  2,X
        A=AC-(0+X)              ;         SBC  0,X
        (2+X)=A                 ;         STA  2,X
        A=(3+X)                 ;         LDA  3,X
        A=AC-(1+X)              ;         SBC  1,X
        (3+X)=A                 ;         STA  3,X
        X=++                    ;         POP
        #=!                     ;  mi1$:  RTS

;----------------------------------------
L004    ?=2,"1+"
        ?=L003
;
one_plus
        A=1
        !=push_byte
        !=plus
        #=!

;----------------------------------------
L005    ?=4,"swap"
        ?=L004
;
swap    A=(0+X)                 ; SWAP:   LDA  0,X        ; Swap the top two data-stack cells.  ( n1 n2 -- n2 n1 )
        Y=(2+X)                 ;         LDY  2,X
        (2+X)=A                 ;         STA  2,X
        (0+X)=Y                 ;         STY  0,X

        A=(1+X)                 ;         LDA  1,X
        Y=(3+X)                 ;         LDY  3,X
        (3+X)=A                 ;         STA  3,X
        (1+X)=Y                 ;         STY  1,X
        #=!                     ;         RTS

;----------------------------------------
L006    ?=3,"dup"
        ?=L005
;
dup     X=--                    ; DUP:    DEX2            ; This could be shortened by a few bytes by using PUSH,
        A=(2+X)                 ;         LDA  2,X        ; but it's used often enough that I think it's worth
        (0+X)=A                 ;         STA  0,X        ; doing this way.                       ( n1 -- n1 n1 )
        A=(3+X)                 ;         LDA  3,X        ; It just DUPlicates the top stack cell.
        (1+X)=A                 ;         STA  1,X
        #=!                     ;  durt$: RTS

;----------------------------------------
; division
L007    ?=1,"/"
        ?=L006
;
slash               ; '/'
        !=divmod
        X=++
        #=!

;----------------------------------------
L008    ?=1,"%"
        ?=L007
;
percent             ; '%'
        !=divmod
        !=swap
        X=++
        #=!

;----------------------------------------
L009    ?=6,"divmod"
        ?=L008
;
divmod                          ; copy and modified from http://www.6502.org/source/interpreters/vtl02.htm
        A=0                     ; lda  #0
        (N)=A                   ; sta  remn	; {%} = 0
        (N+1)=A                 ; sta  remn+1
        A=16                    ; lda  #16
        (N+2)=A                 ; sta  under	; {_} = loop counter
.1      (2+X)=<                 ; asl  0,x	; var[x] is gradually replaced
        (3+X)=(                 ; rol  1,x	;   with the quotient
        (N)=(                   ; rol  remn	; {%} is gradually replaced
        (N+X)=(                 ; rol  remn+1	;   with the remainder
        A=(N)                   ; lda  remn
        T=A-(0+X)               ; cmp  2,x
        A=(N+1)                 ; lda  remn+1	; partial remainder >= var[x+2]?
        A=AC-(1+X)              ; sbc  3,x
        ;=CC,.2                 ; bcc  div2
        (N+1)=A                 ; sta  remn+1	;   yes: update the partial
        A=(N)                   ; lda  remn	;     remainder and set the
        A=AC-(0+X)              ; sbc  2,x	;     low bit in the partial
        (N)=A                   ; sta  remn	;     quotient
        (2+X)=+                 ; inc  0,x
.2      (N+2)=-                 ; dec  under
        ;=NE,.1                 ; bne  div1	; loop 16 times
        A=(N)
        (0+X)=A
        A=(N+1)
        (1+X)=A
        #=!                     ; rts  

;----------------------------------------
; print stack contents          ( -- )
;   S[3]: 0001 0002 0003
L010    ?=2,".s"
        ?=L009
;
print_stack
    A='S' !=cout
    A='[' !=cout
    A=X                 ; A <- stack ptr
    ;=Z,.skip           ; if ptr is zero?
    A=A^$ff             ;   no: convert to positive using 2s compliment
    A=A+1
.skip
    A=>                 ; A=A/2 because stack is 2bytes width
    ;=A>$0A A=A+7       ; val 10 to char 'A'
    A=A+$30             ; val to ascii
    !=cout
    A=']' !=cout
    A=':' !=cout
    ;=X=0 #=advance_cursor  ; stop if empty
.print_stack_value
    A=$20 !=cout
    !=dup
    A=(1+X)
    (0+X)=A
    !=put_hex           ; print hi byte of TOS
    !=dup
    !=put_hex

    ;; next stack entry
    X=++
    ;=X>1 #=.print_stack_value
    !=advance_cursor
    #=!

;----------------------------------------
; pop 1 and show value          ( w -- )
L011    ?=1,"."
        ?=L010
;
period
    !=dup
    (ysave)=Y
    !=put_decimal
    !=advance_cursor

    Y=(ysave)
    #=!

;----------------------------------------
; push random 16 bit number     ( -- w )
L012    ?=4,"rand"
        ?=L011
;
rand
        A=(random)              ; ALL 0 -> initial state
        A=A|(random+1)
        ;=NE,.1
            A=(nmi_count)       ; initialize seed
            (random)=A          ;   from nmi counter
            A=(cursor_x)        ;   and cursor (x,y)
            A=<<<<
            A=A|(cursor_y)
            (random+1)=A
.1
        !=galois16
        X=--
        (0+X)=A
        A=(random+1)
        (1+X)=A
        #=!

;----------------------------------------
; push random dice number 1..6    ( -- w )
;   rand 6 % 1 +
L013    ?=4,"dice"
        ?=L012
;
dice
        !=rand              ; rand
        A=6
        X=--                ; 6
        (0+X)=A
        A=0
        (1+X)=A
        !=percent           ; %
        X=--                ; 1
        A=1
        (0+X)=A
        A=0
        (1+X)=A
        !=plus              ; +
        #=!

;----------------------------------------
; Fetch n at addr.                  ( addr -- n )
L014    ?=5,"fetch"
        ?=L013
;
fetch   A=[0+X]                 ; FETCH:  LDA  (0,X)
        [=A                     ;         PHA
        (0+X)=+                 ;         INC  0,X
        ;=\,.1                  ;         BNE  1$
        (1+X)=+                 ;         INC  1,X
.1      A=[0+X]                 ;  1$:    LDA  (0,X)
        (1+X)=A                 ; PUT:    STA  1,X
        A=]                     ;         PLA
        (0+X)=A                 ;         STA  0,X
        #=!                     ;         RTS

;----------------------------------------
; Store n at addr.                  ( n addr -- )
L015    ?=5,"store"
        ?=L014
;
store   A=(2+X)                 ; STORE:  LDA  2,X
        [0+X]=A                 ;         STA  (0,X)
        (0+X)=+                 ;         INC  0,X
        ;=\,.1                  ;         BNE  st1$
        (1+X)=+                 ;         INC  1,X
.1      A=(3+X)                 ;  st1$:  LDA  3,X
        [0+X]=A                 ;  st2$:  STA  (0,X)
        X=++++                  ;         POP2
        #=!                     ;         RTS

;----------------------------------------
; Fetch b at addr.                  ( addr -- b )
L016    ?=10,"fetch_byte"
        ?=L015
;
fetch_byte
        A=[0+X]
        (0+X)=A
        A=0
        (1+X)=A
        #=!

;----------------------------------------
DICT    :=L016              ; word dict first entry

; Program END

;===============================================================================

;; .segment "RODATA"
example_palette
        ?=$0F,$20,$0F,$30   ;  bg0 white / black
        ?=$0C,$20,$01,$29   ;  bg1 white / blue
        ?=$0F,$15,$26,$37   ;  bg2 purple/pink
        ?=$0F,$01,$11,$21   ;  bg3 blue
        ?=$0F,$35,$28,$38   ;  sp0 yellow
        ?=$0F,$14,$24,$34   ;  sp1 purple
        ?=$0F,$1B,$2B,$3B   ;  sp2 teal
        ?=$0F,$12,$22,$32   ;  sp3 marine

keycode_table
        ; -- keyboard matrix (8x9) --
        ; F8  RET [  ]   KANA RSFT ￥  STOP
        ; F7  @   ;  :   _    /    -   ^
        ; F6  O   L  K   ,    .    P   0
        ; F5  I   U  J   M    N    9   8
        ; F4  Y   G  H   B    V    7   6
        ; F3  T   R  D   F    C    5   4
        ; F2  W   S  A   X    Z    E   3
        ; F1  ESC Q  CTR LSFT GRPH 1   2
        ; CLR ↑   →  ←   ↓    SPC  DEL INS
        ?=$18,$01,"[]",$02,$03,$5C,$04
        ?=$17,"@;:_/-^"
        ?=$16,"olk.,p0"
        ?=$15,"iujmn98"
        ?=$14,"yghbv76"
        ?=$13,"trdfc54"
        ?=$12,"wsaxze3"
        ?=$11,$05,"q",$06,$07,$08,"12"
        ?=$09,$0A,$0B,$0C,$0D,$20,$0E,$0F

keycode_table_shifted
        ?=$18,$01,"[]",$02,$03,$5C,$04
        ?=$17,"@+*_?=^"
        ?=$16,"OLK><P0"
        ?=$15,"IUJMN)("
        ?=$14,"YGHBV'&"
        ?=$13,"TRDFC%$"
        ?=$12,"WSAXZE#"
        ?=$11,$05,"Q",$06,$07,$08,"!",$22
        ?=$09,$0A,$0B,$0C,$0D,$20,$0E,$0F

        $=$00,$fffa-*       ;;.segment "VECINFO"
        ?=nmi               ;         .word        $0000
        ?=reset             ;         .word        Reset
        ?=irq               ;         .word        $0000

        *=$0000
        &="chr_files/typewriter.chr"