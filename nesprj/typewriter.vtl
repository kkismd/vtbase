;; PPU I/O registers
PPU_CTRL1       :=$2000
PPU_CTRL2       :=$2001
PPU_STATUS      :=$2002
PPU_SPR_ADDR    :=$2003
PPU_SPR_IO      :=$2004
PPU_VRAM_ADDR1  :=$2005
PPU_VRAM_ADDR2  :=$2006
PPU_VRAM_IO     :=$2007

BG_PALETTE_TBL  :=$3f00
SPR_PALETTE_TBL :=$3f10

SCREEN_WIDTH    :=32
SCREEN_HEIGHT   :=29

VRAM_NAME_TBL   :=$2000
VRAM_ATTR_TBL   :=$23c0

APU_DMC_IRQ     :=$4010
APU_STATUS      :=$4015
KBD_CTRL        :=$4016
KBD_IO          :=$4017
APU_FRAME_CNT   :=$4017

                                ;; https://github.com/bbbradsmith/NES-ca65-example
                                ;; example.s
                                ;; Brad Smith (rainwarrior), 4/06/2014
                                ;; http://rainwarrior.ca

                                ;; ## License
                                ;; This program and source code can be freely redistributed, modified or reused in any way.
                                ;; Credit is not required, but attribution is always appreciated.

                                ;; .segment "OAM"
OAM             :=$0200         ;; oam: .res 256        ; sprite OAM data to be uploaded by DMA
                                ;; .segment "BSS"
nmt_update      :=$0300         ;; nmt_update: .res 256 ; nametable update entry buffer for PPU update
palette         :=$0400         ;; palette:    .res 32  ; palette buffer for PPU update




;; zero page                    ;; .segment "ZEROPAGE"
nmi_lock        :=$00           ;; nmi_lock:       .res 1 ; prevents NMI re-entry
nmi_count       :=$01           ;; nmi_count:      .res 1 ; is incremented every NMI
nmi_ready       :=$02           ;; nmi_ready:      .res 1 ; set to 1 to push a PPU frame update,
                                ;;                        ; 2 to turn rendering off next NMI
nmt_update_len  :=$03           ;; nmt_update_len: .res 1 ; number of bytes in nmt_update buffer



temp            :=$07           ;; temp:           .res 1 ; temporary variable
gamepad         :=$08           ;; gamepad:        .res 1
cursor_x        :=$09           ;; cursor_x: .res 1
cursor_y        :=$0a           ;; cursor_y: .res 1
temp_x          :=$0b           ;; temp_x:   .res 1
temp_y          :=$0c           ;; temp_y:   .res 1
upd             :=$0d           ;; game update mode (p_move=0, p_turn=1)
offset_x        :=$0e
offset_y        :=$0f
buttons         :=$10           ;; button push state
p_timer         :=$11           ;; player animation timer

xsave           :=$12
hex_l           :=$13
hex_h           :=$14
tmp1            :=$15
tmp2            :=$16


keyin_data      :=$17           ;; 9 bytes
keyin_data_bit  :=$20           ;; 96 bytes


nes_header                      ;; iNESヘッダ
        ?="NES",$1A             ;; "NES" Header
        ?=$02                   ;;  PRG-BANKS
        ?=$01                   ;;  CHR-BANKS
        ?=$01                   ;;  horizontal Mirror
        ?=$00                   ;;  
        ?=$00,$00,$00,$00       ;;  
        ?=$00,$00,$00,$00       ;;  

        *=$8000                 ;; .segment "STARTUP"

reset                           ;; proc Reset
        I=1                     ;;      sei
        A=0                     ;;      lda #0
        (PPU_CTRL1)=A           ;;      sta $2000
        (PPU_CTRL2)=A           ;;      sta $2001
        (APU_STATUS)=A          ;;      sta $4015 ; disable APU sound
        (APU_DMC_IRQ)=A         ;;      sta $4010 ; disable DMC IRQ
        A=$40                   ;;      lda #$40
        (APU_FRAME_CNT)=A       ;;      sta $4017 ; disable APU IRQ
        D=0                     ;;      cld       ; disable decimal mode
        X=$ff                   ;;      ldx #$ff
        S=X                     ;;      txs

                                ;;; wait for first vblank
        T=A&(PPU_STATUS)        ;;      bit $2002
.1                              ;;      :
        T=A&(PPU_STATUS)        ;;      bit $2002
        ;=PL,.1                 ;;      bpl :-

                                ;; ; clear all RAM to 0
        A=0                     ;; lda #0
        X=0                     ;; ldx #0
.2                              ;; :
        ($00+X)=A               ;;    sta $0000, X
        ($0100+X)=A             ;;    sta $0100, X
        ($0200+X)=A             ;;    sta $0200, X
        ($0300+X)=A             ;;    sta $0300, X
        ($0400+X)=A             ;;    sta $0400, X
        ($0500+X)=A             ;;    sta $0500, X
        ($0600+X)=A             ;;    sta $0600, X
        ($0700+X)=A             ;;    sta $0700, X
        X=+                     ;;    inx
        ;=NE,.2                 ;;    bne :-
                                ;; ; place all sprites offscreen at Y=255
        A=255                   ;; lda #255
        X=0                     ;; ldx #0
.3                              ;; :
        (OAM+X)=A               ;;         sta oam, X
        X=++++                  ;;         inx
                                ;;         inx
                                ;;         inx
                                ;;         inx
        ;=NE,.3                 ;;         bne :-
                                ;; ; wait for second vblank
.4                              ;; :
        T=A&(PPU_STATUS)        ;;         bit $2002
        ;=PL,.4                 ;;         bpl :-

                                ;; ; NES is initialized, ready to begin!
                                ;; ; enable the NMI for graphical updates, and jump to our main program
        A=%10001000             ;; lda #%10001000
        (PPU_CTRL1)=A           ;; sta $2000
        #=main                  ;; jmp main

nmi                             ;; nmi:
                                ;;     ; save registers
        [=A                     ;;     pha
        A=X                     ;;     txa
        [=A                     ;;     pha
        A=Y                     ;;     tya
        [=A                     ;;     pha
                                ;;     ; prevent NMI re-entry
        A=(nmi_lock)            ;;     lda nmi_lock
        ;=EQ,.1                 ;;     beq :+
        #=.nmi_end              ;;         jmp @nmi_end
.1                              ;;     :
        A=1                     ;;     lda #1
        (nmi_lock)=A            ;;     sta nmi_lock
                                ;;     ; increment frame counter
        (nmi_count)=+           ;;     inc nmi_count
                                ;;     ;
        A=(nmi_ready)           ;;     lda nmi_ready
        ;=NE,.2                 ;;     bne :+ ; nmi_ready == 0 not ready to update PPU
        #=.ppu_update_end       ;;         jmp @ppu_update_end
.2                              ;;     :
        T=A-2                   ;;     cmp #2 ; nmi_ready == 2 turns rendering off
        ;=NE,.3                 ;;     bne :+
        A=%00000000             ;;         lda #%00000000
        (PPU_CTRL2)=A           ;;         sta $2001
        X=0                     ;;         ldx #0
        (nmi_ready)=X           ;;         stx nmi_ready
        #=.ppu_update_end       ;;         jmp @ppu_update_end
.3                              ;;     :
                                ;;     ; sprite OAM DMA
        X=0                     ;;     ldx #0
        (PPU_SPR_ADDR)=X        ;;     stx $2003
        A=>OAM                  ;;     lda #>oam
        ($4014)=A               ;;     sta $4014
                                ;;     ; palettes
        A=%10001000             ;;     lda #%10001000
        (PPU_CTRL1)=A           ;;     sta $2000 ; set horizontal nametable increment
        A=(PPU_STATUS)          ;;     lda $2002
        A=$3f                   ;;     lda #$3F
        (PPU_VRAM_ADDR2)=A      ;;     sta $2006
        (PPU_VRAM_ADDR2)=X      ;;     stx $2006 ; set PPU address to $3F00
        X=0                     ;;     ldx #0
.4                              ;;     :
        A=(palette+X)           ;;         lda palette, X
        (PPU_VRAM_IO)=A         ;;         sta $2007
        X=+                     ;;         inx
        T=X-32                  ;;         cpx #32
        ;=CC,.4                 ;;         bcc :-
                                ;;     ; nametable update
        X=0                     ;;     ldx #0
        T=X-(nmt_update_len)    ;;     cpx nmt_update_len
        ;=CS,.scroll            ;;     bcs @scroll
.nmt_update_loop                ;;     @nmt_update_loop:
        A=(nmt_update+X)        ;;         lda nmt_update, X
        (PPU_VRAM_ADDR2)=A      ;;         sta $2006
        X=+                     ;;         inx
        A=(nmt_update+X)        ;;         lda nmt_update, X
        (PPU_VRAM_ADDR2)=A      ;;         sta $2006
        X=+                     ;;         inx
        A=(nmt_update+X)        ;;         lda nmt_update, X
        (PPU_VRAM_IO)=A         ;;         sta $2007
        X=+                     ;;         inx
        T=X-(nmt_update_len)    ;;         cpx nmt_update_len
        ;=CC,.nmt_update_loop   ;;         bcc @nmt_update_loop
        A=0                     ;;     lda #0
        (nmt_update_len)=A      ;;     sta nmt_update_len
.scroll                         ;; @scroll:
        A=0
        A=A&%00000011           ;;     and #%00000011 ; keep only lowest 2 bits to prevent error
        A=A|%10001000           ;;     ora #%10001000
        (PPU_CTRL1)=A           ;;     sta $2000

        A=0                     ;;     ; set value of scroll_x
        (PPU_VRAM_ADDR1)=A      ;;     sta $2005

        A=0                     ;;     ; set value of scroll_y
        (PPU_VRAM_ADDR1)=A      ;;     sta $2005
                                ;;     ; enable rendering
        A=%00011110             ;;     lda #%00011110
        (PPU_CTRL2)=A           ;;     sta $2001
                                ;;     ; flag PPU update complete
        X=0                     ;;     ldx #0
        (nmi_ready)=X           ;;     stx nmi_ready

.ppu_update_end                 ;; @ppu_update_end:
                                ;;     ; if this engine had music/sound, this would be a good place to play it
                                ;;     ; unlock re-entry flag
        A=0                     ;;     lda #0
        (nmi_lock)=A            ;;     sta nmi_lock
.nmi_end                        ;; @nmi_end:
                                ;;     ; restore registers and return
        A=]                     ;;     pla
        Y=A                     ;;     tay
        A=]                     ;;     pla
        X=A                     ;;     tax
        A=]                     ;;     pla
        #=~                     ;;     rti

                                ;; .segment "CODE"
irq                             ;; irq:
        #=~                     ;;     rti

                                ;; ; ppu_update: waits until next NMI, turns rendering on (if not already),
                                ;;   uploads OAM, palette, and nametable update to PPU
ppu_update                      ;; ppu_update:
        A=1                     ;;     lda #1
        (nmi_ready)=A           ;;     sta nmi_ready
.1                              ;;     :
        A=(nmi_ready)           ;;         lda nmi_ready
        ;=NE,.1                 ;;         bne :-
        #=!                     ;;     rts
                                ;; 
                                ;; ; ppu_skip: waits until next NMI, does not update PPU
ppu_skip                        ;; ppu_skip:
        A=(nmi_count)           ;;     lda nmi_count
.1                              ;;     :
        T=A-(nmi_count)         ;;         cmp nmi_count
        ;=EQ,.1                 ;;         beq :-
        #=!                     ;;     rts
                                ;; 
                                ;; ; ppu_off: waits until next NMI, turns rendering off 
                                ;;   (now safe to write PPU directly via $2007)
ppu_off                         ;; ppu_off:
        A=2                     ;;     lda #2
        (nmi_ready)=A           ;;     sta nmi_ready
.1                              ;;     :
        A=(nmi_ready)           ;;         lda nmi_ready
        ;=NE,.1                 ;;         bne :-
        #=!                     ;;     rts

;; ppu_address_tile: use with rendering off, sets memory address to tile at X/Y, ready for a $2007 write
;;;   Y =  0- 31 nametable $2000
;;;   Y = 32- 63 nametable $2400
;;;   Y = 64- 95 nametable $2800
;;;   Y = 96-127 nametable $2C00
ppu_address_tile                ;; ppu_address_tile:
        A=(PPU_STATUS)          ;;     lda $2002 ; reset latch
        A=Y                     ;;     tya
        A=>>>                   ;;     lsr *3
        A=A|$20                 ;;     ora #$20 ; high bits of Y + $20
        (PPU_VRAM_ADDR2)=A      ;;     sta $2006
        A=Y                     ;;     tya
        A=<<<<<                 ;;     asl *5
        (temp)=A                ;;     sta temp
        A=X                     ;;     txa
        A=A|(temp)              ;;     ora temp
        (PPU_VRAM_ADDR2)=A      ;;     sta $2006 ; low bits of Y + X
        #=!                     ;;     rts


;; ppu_update_tile: can be used with rendering on, sets the tile at X/Y to tile A next time you call ppu_update
ppu_update_tile
        [=A                     ;; pha ; temporarily store A on stack
        A=X                     ;; txa
        [=A                     ;; pha ; temporarily store X on stack
        X=(nmt_update_len)      ;; ldx nmt_update_len
        A=Y                     ;; tya
        A=>>>                   ;; lsr *3
        A=A|$20                 ;; ora #$20 ; high bits of Y + $20
        (nmt_update+X)=A        ;; sta nmt_update, X
        X=+                     ;; inx
        A=Y                     ;; tya
        A=<<<<<                 ;; asl *5
        (temp)=A                ;; sta temp
        A=]                     ;; pla ; recover X value (but put in A)
        A=A|(temp)              ;; ora temp
        (nmt_update+X)=A        ;; sta nmt_update, X
        X=+                     ;; inx
        A=]                     ;; pla ; recover A value (tile)
        (nmt_update+X)=A        ;; sta nmt_update, X
        X=+                     ;; inx
        (nmt_update_len)=X      ;; stx nmt_update_len
        #=!                     ;; rts


;;
;; gamepad
;;

PAD_A       :=$01
PAD_B       :=$02
PAD_SELECT  :=$04
PAD_START   :=$08
PAD_U       :=$10
PAD_U_NOT   :=$ef
PAD_D       :=$20
PAD_D_NOT   :=$df
PAD_L       :=$40
PAD_L_NOT   :=$bf
PAD_R       :=$80
PAD_R_NOT   :=$7f

;; arrow key
ARROW_U     :=$02
ARROW_R     :=$04
ARROW_L     :=$08
ARROW_D     :=$10

;; gamepad_poll: this reads the gamepad state into the variable labelled "gamepad"
;;   This only reads the first gamepad, and also if DPCM samples are played they can
;;   conflict with gamepad reading, which may give incorrect results.
gamepad_poll                ;; gamepad_poll:
                            ;;     ; strobe the gamepad to latch current button state
    A=1                     ;;     lda #1
    ($4016)=A               ;;     sta $4016
    A=0                     ;;     lda #0
    ($4016)=A               ;;     sta $4016
                            ;;     ; read 8 bytes from the interface at $4016
    X=8                     ;;     ldx #8
.1                          ;;     :
    [=A                     ;;         pha
    A=($4016)               ;;         lda $4016
                            ;;         ; combine low two bits and store in carry bit
    A=A&%00000011           ;;         and #%00000011
    T=A-%00000001           ;;         cmp #%00000001
    A=]                     ;;         pla
                            ;;         ; rotate carry into gamepad variable
    A=)                     ;;         ror
    X=-                     ;;         dex
    ;=NE,.1                 ;;         bne :-
    (gamepad)=A             ;;     sta gamepad
    #=!                     ;;     rts

main                        ;;    ; setup 
    X=0                     ;;    ldx #0
.1                          ;;    :
    A=(example_palette+X)   ;;        lda example_palette, X
    (palette+X)=A           ;;        sta palette, X
    X=+                     ;;        inx
    T=X-32                  ;;        cpx #32
    ;=CC,.1                 ;;        bcc :-
    !=setup_background      ;;    jsr setup_background
                            ;;    ; center the cursor
    A=2                     ;;    lda #128
    (cursor_x)=A            ;;    sta cursor_x
    A=2                     ;;    lda #120
    (cursor_y)=A            ;;    sta cursor_y
    A=0
    (p_timer)=A
    (buttons)=A
                            ;;    ; show the screen
    !=draw_cursor           ;;    jsr draw_cursor
    !=ppu_update            ;;    jsr ppu_update
                            ;;    ; main loop
.loop                       ;;@loop:
                            ;;    ; read gamepad
    !=gamepad_poll          ;;    jsr gamepad_poll
                            ;;    ; respond to gamepad state
    A=(gamepad)             ;;    lda gamepad
    A=A&PAD_START           ;;    and #PAD_START
    ;=EQ,.2                 ;;    beq :+

    #=.draw                 ;;        jmp @draw ; start trumps everything, don't check other buttons
.2                          ;;    :

    !=move_player
    A=(gamepad)             ;;    lda gamepad
    A=A&PAD_SELECT          ;;    and #PAD_SELECT
    ;=EQ,.7                 ;;    beq :+
    !=push_select           ;;        jsr push_select
.7                          ;;    :
    A=(gamepad)             ;;    lda gamepad
    A=A&PAD_B               ;;    and #PAD_B
    ;=EQ,.8                 ;;    beq :+
    !=push_b                ;;        jsr push_b
.8                          ;;    :
    A=(gamepad)             ;;    lda gamepad
    A=A&PAD_A               ;;    and #PAD_A
    ;=EQ,.9                 ;;    beq :+
    !=push_a_btn                ;;        jsr push_a
.9                          ;;    :
    !=read_keyboard
    !=disp_keyin_data

.draw                       ;;@draw:
                            ;;    ; draw everything and finish the frame
    !=draw_cursor           ;;    jsr draw_cursor
    !=ppu_update            ;;    jsr ppu_update
                            ;;    ; keep doing this forever!
    #=.loop                 ;;    jmp @loop

move_player
    !=is_up_key_pressed
    ;=EQ,.check_down_key
    A=(buttons)             ;; check state
    ;=NE,.1
    !=push_u
    A=1                     ;; set flag on
    (buttons)=A
.1
    #=!

.check_down_key
    !=is_down_key_pressed
    ;=EQ,.check_left_key
    A=(buttons)             ;; check state
    ;=NE,.2
    !=push_d
    A=1                     ;; set flag on
    (buttons)=A
.2
    #=!

.check_left_key
    !=is_left_key_pressed
    ;=EQ,.check_right_key
    A=(buttons)             ;; check state
    ;=NE,.3
    !=push_l                ;;        jsr push_l
    A=1                     ;; set flag on
    (buttons)=A
.3
    #=!

.check_right_key
    !=is_right_key_pressed
    ;=EQ,.no_button_pressed
    A=(buttons)             ;; check state
    ;=NE,.4
    !=push_r                ;;        jsr push_r
    A=1                     ;; set flag on
    (buttons)=A
.4
    #=!

.no_button_pressed
    A=0                     ;; reset button pushed
    (buttons)=A             ;; because no button pushed
    #=!

; pad up button or kbd up key is pressed?
is_up_key_pressed
    A=(gamepad)
    A=A&PAD_U
    ;=EQ,.1
    #=!
.1
    A=(keyin_data+8)
    A=A^$ff
    A=A&ARROW_U
    #=!

; pad down button or kbd down key is pressed?
is_down_key_pressed
    A=(gamepad)
    A=A&PAD_D
    ;=EQ,.1
    #=!
.1
    A=(keyin_data+8)
    A=A^$ff
    A=A&ARROW_D
    #=!

; pad left button or kbd left key is pressed?
is_left_key_pressed
    A=(gamepad)
    A=A&PAD_L
    ;=EQ,.1
    #=!
.1
    A=(keyin_data+8)
    A=A^$ff
    A=A&ARROW_L
    #=!

is_right_key_pressed
    A=(gamepad)
    A=A&PAD_R
    ;=EQ,.1
    #=!
.1
    A=(keyin_data+8)
    A=A^$ff
    A=A&ARROW_R
    #=!

;-------------------------------------------------------------------------------

read_keyboard               ;; ReadKeyboard:
        A=%00000101             ;;         lda #%00000101          ; デバイス選択＆リセット
        (KBD_CTRL)=A            ;;         sta JOY1
                                ;; 
        !=kbd_wait2             ;;         jsr Wait2
                                ;; 
        X=0                     ;;         ldx #$00
.1      A=%00000100             ;;       - lda #%00000100          ; 下位データを指定
        (KBD_CTRL)=A            ;;         sta JOY1
                                ;; 
        !=kbd_wait1             ;;         jsr Wait1
                                ;; 
        A=(KBD_IO)              ;;         lda JOY2                ; 下位データ読込
        A=>                     ;;         lsr
        A=A&$0f                 ;;         and #$0F
        (keyin_data+X)=A        ;;         sta KeyData ,x
                                ;; 
        A=%00000110             ;;         lda #%00000110          ; 上位データを指定
        (KBD_CTRL)=A            ;;         sta JOY1
                                ;; 
        !=kbd_wait1             ;;         jsr Wait1
                                ;; 
        A=(KBD_IO)              ;;         lda JOY2                ; 上位データ読込
        A=<<<                   ;;         asl *3
        A=A&$f0                 ;;         and #$F0
        A=A|(keyin_data+X)      ;;         ora KeyData ,x          ; 下位データと上位データを合成
        (keyin_data+X)=A        ;;         sta KeyData ,x
                                ;; 
        X=+                     ;;         inx
        T=X-9                   ;;         cpx #$09
        ;=NE,.1                 ;;         bne -
                                ;; 
        #=!                     ;;         rts
                                ;; 
                                ;; ;-------------------------------------------------------------------------------
kbd_wait1                       ;; Wait1:                          ; ウエイト
        Y=8                     ;;         ldy #$08
.1      Y=-                     ;;       - dey
        ;=NE,.1                 ;;         bne -
        _                       ;;         nop
kbd_wait2                       ;; Wait2:
        #=!                     ;;         rts

disp_keyin_data
        X=0
        A=(keyin_data+X)
        A=A&$0f
        A=A|$30
        Y=26                ;; Y座標
        !=ppu_update_tile
        #=!

;; Aの値をhex2文字に変換する
numhex
        (tmp1)=A               ;; Aの値を保存
        A=>>>>                 ;; 上位4bitを下位にずらす
        !=hexchar              ;; 文字に変換
        (tmp2)=A               ;; 1文字目を一時保存
        A=(tmp1)               ;; もう一度Aの値を取り出す   
        A=A&$0f                ;; 上位4bitをマスクする
        !=hexchar              ;; 文字に変換
        Y=A                    ;; 2文字目をYに保存
        A=(tmp2)               ;; 1文字目をAに戻す
        #=!                    ;; 終わり

;; Aレジスタ下位4bitの値を0-Fの文字に変換する
hexchar
        ;=A>$0a A=A+7
        A=A+48
        #=!

push_u                      ;; push_u:
    (cursor_y)=-            ;;     dec cursor_y
                            ;;     ; Y wraps at 240
    A=(cursor_y)            ;;     lda cursor_y
    ;=PL,.1                 ;;     bcc :+
    A=29                    ;;         lda #239
    (cursor_y)=A            ;;         sta cursor_y
.1                          ;;     :
    #=!                     ;;     rts

push_d                      ;; push_d:
    (cursor_y)=+            ;;     inc cursor_y
    A=(cursor_y)            ;;     lda cursor_y
    ;=A>30 A=0 (cursor_y)=A ;; ; wrap over L30
.1                          ;;     :
    #=!                     ;;     rts

push_l                      ;; push_l:
    (cursor_x)=-            ;;     dec cursor_x
.1
    #=!                     ;;     rts

push_r                      ;; push_r:
    (cursor_x)=+            ;;     inc cursor_x
.1
    #=!                     ;;     rts

push_select                 ;; push_select:
                            ;;     ; turn off rendering so we can manually update entire nametable
    !=ppu_off               ;;     jsr ppu_off
    !=setup_background      ;;     jsr setup_background
.1                          ;;     ; wait for user to release select before continuing
                            ;;     :
    !=gamepad_poll          ;;         jsr gamepad_poll
    A=(gamepad)             ;;         lda gamepad
    A=A&PAD_SELECT          ;;         and #PAD_SELECT
    ;=NE,.1                 ;;         bne :-
    #=!                     ;;     rts

push_b                      ;; push_b:
    A=(cursor_x)            ;;     lda cursor_x
    X=A                     ;;     tax ; X = cursor_x
    A=(cursor_y)            ;;     lda cursor_y
    Y=A                     ;;     tay ; Y = cursor_y
    A=$20                   ;;     lda #4
    !=ppu_update_tile       ;;     jsr ppu_update_tile ; puts tile 4 at X/Y
    #=!                     ;;     rts

push_a_btn                      ;; push_a:
    A=$40
    X=3
    Y=4
    !=ppu_update_tile       ;;     jsr ppu_update_tile ; puts tile 4 at X/Y
    #=!                     ;;     rts

draw_cursor                 ;; draw_cursor:
                            ;;     ; y position (note, needs to be one line higher than sprite's appearance)
    A=(cursor_y)            ;;     lda cursor_y
    A=<<<                   ;;      x8
    A=A-2
    (OAM)=A                 ;;     sta oam+(0*4)+0
                            ;;     ; tile
    A=(nmi_count)           ;;     lda #1
    A=A&%01110000
    A=>>>>>
    A=A+$e0
    (OAM+1)=A               ;;     sta oam+(0*4)+1
                            ;;     ; attributes
    A=%00000000             ;;     lda #%00000000 ; no flip
    (OAM+2)=A               ;;     sta oam+(0*4)+2
                            ;;     ; x position
    A=(cursor_x)            ;;     lda cursor_x
    A=<<<                   ;;      x8
    (OAM+3)=A               ;;     sta oam+(0*4)+3
    #=!                     ;;     rts

setup_background                ;; setup_background:
                                ;;     ; first nametable, start by clearing to empty
        A=(PPU_STATUS)          ;;     lda $2002 ; reset latch
        A=$20                   ;;     lda #$20
        (PPU_VRAM_ADDR2)=A      ;;     sta $2006
        A=$00                   ;;     lda #$00
        (PPU_VRAM_ADDR2)=A      ;;     sta $2006
                                ;;     ; empty nametable
        ;; '!' から '~' までを範囲としてコードを変化させる
        ;; SPC ' ' $20 = %0010 0000
        ;; TLD '~' $7e = %0111 1110
        A=$21                   ;; 初期値
        Y=30                    ;;     ldy #30 ; 30 rows
.1                              ;;     :
        X=32                    ;;         ldx #32 ; 32 columns
.2                              ;;         :
        (PPU_VRAM_IO)=A         ;;             sta $2007
        A=A+1
        ;=A>$7e A=$21
        X=-                     ;;             dex
        ;=NE,.2                 ;;             bne :-
        Y=-                     ;;         dey
        ;=NE,.1                 ;;         bne :--
                                ;;     ; set all attributes to 0
        X=64                    ;;     ldx #64 ; 64 bytes
        A=0
.3                              ;;     :
        (PPU_VRAM_IO)=A         ;;         sta $2007
        X=-                     ;;         dex
        ;=NE,.3                 ;;         bne :-

                                ;;; draw map
        A=$20                   ;; setup ppu write address
        (PPU_VRAM_ADDR2)=A
        A=$00
        (PPU_VRAM_ADDR2)=A

        #=!                     ;;     rts

;; .segment "RODATA"
example_palette
        ?=$0F,$10,$38,$2d   ;; bg0 purple/pink
        ?=$0F,$09,$19,$29   ;; bg1 green
        ?=$0F,$01,$11,$21   ;; bg2 blue
        ?=$0F,$00,$10,$30   ;; bg3 greyscale
        ?=$0F,$35,$28,$38   ;; sp0 yellow
        ?=$0F,$14,$24,$34   ;; sp1 purple
        ?=$0F,$1B,$2B,$3B   ;; sp2 teal
        ?=$0F,$12,$22,$32   ;; sp3 marine

        $=$00,$fffa-*       ;;.segment "VECINFO"                       
        ?=nmi               ;;        .word        $0000
        ?=reset             ;;        .word        Reset
        ?=irq               ;;        .word        $0000

        *=$0000
        &="chr_files/typewriter.chr"