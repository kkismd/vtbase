;; Subroutines in this library are ported from
;;   http://wilsonminesco.com/stacks/


;; 8 bytes variable space at zeropage
N       :=$01

zero                            ;; ZERO:                        ; ZERO and
false                           ;; FALSE:                       ; FALSE (to pu the constant -1 on the stack
push_false                      ;; PUSH_FALSE: DEX2             ; use the same code as PUSH_FALSE.
        X=--
set_false                       ;; SET_FALSE:  STZ   1,X        ; NMOS will need to load A or Y with 0 to store.
        A=0 (1+X)=A             ;;             STZ   0,X
        (0+X)=A
        #=!                     ;;             RTS

one     A=1                     ;; ONE:    LDA  #1         ; Put 1 on the data stack.      ( -- 1 )
one_o1  X=--                    ;;  o1$:   DEX2
        (0+X)=A                 ;;         STA  0,X
        A=0 (1+X)=A             ;;         STZ  1,X
        #=!                     ;;         RTS
                                ;;--------------
                                ;; 
two     A=2                     ;; TWO:    LDA  #2         ; Put 2 on the data stack.      ( -- 2 )
        C=0 ;=<,one_o1          ;;         BRA  o1$
                                ;;--------------
                                ;; 
three   A=3                     ;; THREE:  LDA  #3         ; Put 3 on the data stack.      ( -- 3 )
        C=0 ;=<,one_o1          ;;         BRA  o1$
                                ;;--------------
                                ;;         
four    A=4                     ;; FOUR:   LDA  #4
        C=0 ;=<,one_o1          ;;         BRA  o1$


bl      A=$20                   ;; BL:     LDA  #$20       ; Put $20, the blank (space) char, on the data stack.
        X=--                    ;;  bl1$   DEX2
        (0+X)=A                 ;;         STA  0,X
        A=0 (1+X)=A             ;;         STZ  1,X
        #=!                     ;;         RTS

fetch   A=(0+X)                 ;; FETCH:  LDA  (0,X
        [=A                     ;;         PHA
        (0+X)=+                 ;;         INC  0,X
        ;=\,.1                  ;;         BNE  1$
        (1+X)=+                 ;;         INC  1,X
.1      A=(0+X)                 ;;  1$:    LDA  (0,X)
        C=0 ;=<,put             ;;         BRA  PUT

push    X=--                    ;; PUSH:   DEX2

put     (1+X)=A                 ;; PUT:    STA  1,X
        A=]                     ;;         PLA
        (0+X)=A                 ;;         STA  0,X
        #=!                     ;;         RTS



;; multiply                     ( n1 n2 -- n1*n2 )
star    A=Y [=A                 ;; STAR:   PHY
        A=0 (N)=A               ;;         STZ  N
        Y=0                     ;;         LDY  #0
.1      >=(3+X)                 ;; sta1$:     LSR  3,X
        )=(2+X)                 ;;            ROR  2,X
        ;=<,.2                  ;;            BCC  sta2$
        C=0                     ;;               CLC
        A=(N)                   ;;               LDA  N
        A=A+(0+X)               ;;               ADC  0,X
        (N)=A                   ;;               STA  N
        A=Y                     ;;               TYA
        A=AC+(1+X)              ;;            ADC  1,X
        Y=A                     ;;            TAY
.2      <=(0+X)                 ;; sta2$:     ASL  0,X
        (=(1+X)                 ;;            ROL  1,X
                                ;; 
        A=(2+X)                 ;;            LDA  2,X
        A=A|(3+X)               ;;            ORA  3,X
        ;=\,.1                  ;;         BNE  sta1$
                                ;; 
        A=(N)                   ;;         LDA  N
        (2+X)=A                 ;;         STA  2,X
        (3+X)=Y                 ;;         STY  3,X
        X=+                     ;;         INX
        X=+                     ;;         INX
        A=]                     ;;         PLY
        Y=A
        #=!                     ;;         RTS

;; add                          ( n1 n2  --  n1+n2 )
plus                            ;; PLUS:   CLC             
        A=(0+X)                 ;;         LDA  0,X
        A=A+(2+X)               ;;         ADC  2,X
        (2+X)=A                 ;;         STA  2,X
        A=(1+X)                 ;;         LDA  1,X
        A=AC+(3+X)              ;;         ADC  3,X
        (3+X)=A                 ;;         STA  3,X
        X=++                    ;;         POP
        #=!                     ;;         RTS

;; subtract                     ( n1 n2  --  n1-n2 )
minus   C=1                     ;; MINUS:  SEC             
        A=(2+X)                 ;;         LDA  2,X
        A=AC-(0+X)              ;;         SBC  0,X
        (2+X)=A                 ;;         STA  2,X
        A=(3+X)                 ;;         LDA  3,X
        A=AC-(1+X)              ;;         SBC  1,X
        (3+X)=A                 ;;         STA  3,X
        X=++                    ;;         POP
        #=!                     ;;  mi1$:  RTS

over    X=--                    ;; OVER:   DEX2            ; This could be shortened by a few bytes by using PUSH,
        A=(4+X)                 ;;         LDA  4,X        ; but it's used often enough that I think it's worth
        (0+X)=A                 ;;         STA  0,X        ; doing this way.                ( n1 n2 -- n1 n2 n1 )
        A=(5+X)                 ;;         LDA  5,X        ; It makes a copy of the cell below the top of stack.
        (1+X)=A                 ;;         STA  1,X        ; 32 clocks, incl JSR & RTS.
        #=!                     ;;         RTS

dup     X=--                    ;; DUP:    DEX2            ; This could be shortened by a few bytes by using PUSH,
        A=(2+X)                 ;;         LDA  2,X        ; but it's used often enough that I think it's worth
        (0+X)=A                 ;;         STA  0,X        ; doing this way.                       ( n1 -- n1 n1 )
        A=(3+X)                 ;;         LDA  3,X        ; It just DUPlicates the top stack cell.
        (1+X)=A                 ;;         STA  1,X
        #=!                     ;;  durt$: RTS

;; VRAMの指定アドレスに値を書き込む
;; ( addr c -- )
write_to_vram
        A=(3+X)                 ;; アドレス上位
        (PPU_VRAM_ADDR2)=A      ;; 
        A=(2+X)                 ;; アドレス下位
        (PPU_VRAM_ADDR2)=A      ;;  
        A=(0+X)                 ;; 出力したい文字
        (PPU_VRAM_IO)=A         ;; VRAMに書き込み
        X=++++                  ;; スタック解放
        #=!                     ;; 終わり


;; 指定した座標をアドレスに変換、PPUレジスタにセット
;; ( x y -- )
locate
        ;; 1行あたりの文字数をスタックに積む
        X=--
        A=0
        (1+X)=A
        A=SCREEN_WIDTH
        (0+X)=A

        !=star                  ;; y * SCREEN_WIDTH
        !=plus                  ;; + x

        ;; ネームテーブルの先頭アドレスをスタックに積む
        X=--                    ;; スタックのボトムセルは $fe + $ff
        A=>VRAM_NAME_TBL
        (1+X)=A
        A=<VRAM_NAME_TBL
        (0+X)=A

        !=plus                  ;; + $2000

        A=(1+X)                 ;; アドレス上位
        (PPU_VRAM_ADDR2)=A      ;; 
        A=(0+X)                 ;; アドレス下位
        (PPU_VRAM_ADDR2)=A      ;;  

        #=!
